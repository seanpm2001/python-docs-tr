
<!DOCTYPE html>

<html lang="tr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="9. Sınıflar" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/tutorial/classes.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Sınıflar, verileri ve işlevleri bir arada tutan bir araçtır. Yeni bir sınıf oluşturulurken, objeye ait yeni örnekler (instances) oluşturulur. Sınıf örnekleri, durumlarını korumak için onlara ilişti..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Sınıflar, verileri ve işlevleri bir arada tutan bir araçtır. Yeni bir sınıf oluşturulurken, objeye ait yeni örnekler (instances) oluşturulur. Sınıf örnekleri, durumlarını korumak için onlara ilişti..." />
<meta property="og:image:width" content="200">
<meta property="og:image:height" content="200">
<meta name="theme-color" content="#3776ab">

    <title>9. Sınıflar &#8212; Python 3.11.1 belgelendirmesi</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?2022.1" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.11.1 belgelendirmesi içinde ara"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Bu belgeler hakkında" href="../about.html" />
    <link rel="index" title="Dizin" href="../genindex.html" />
    <link rel="search" title="Ara" href="../search.html" />
    <link rel="copyright" title="Telif Hakkı" href="../copyright.html" />
    <link rel="next" title="10. Standart Kütüphanenin Özeti" href="stdlib.html" />
    <link rel="prev" title="8. Hatalar ve Özel Durumlar" href="errors.html" />
    <link rel="canonical" href="https://docs.python.org/3/tutorial/classes.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Hızlı Arama"/>
            <input type="submit" value="Git"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">İçindekiler</a></h3>
    <ul>
<li><a class="reference internal" href="#">9. Sınıflar</a><ul>
<li><a class="reference internal" href="#a-word-about-names-and-objects">9.1. İsim ve Nesneler Hakkında Birkaç Şey</a></li>
<li><a class="reference internal" href="#python-scopes-and-namespaces">9.2. Python Etki Alanları ve Ad Alanları</a><ul>
<li><a class="reference internal" href="#scopes-and-namespaces-example">9.2.1. Kapsamlar ve Ad Alanları Örneği</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-first-look-at-classes">9.3. Sınıflara İlk Bakış</a><ul>
<li><a class="reference internal" href="#class-definition-syntax">9.3.1. Sınıf Tanımlama Söz Dizimi</a></li>
<li><a class="reference internal" href="#class-objects">9.3.2. Sınıf Nesneleri</a></li>
<li><a class="reference internal" href="#instance-objects">9.3.3. Örnek Nesneleri</a></li>
<li><a class="reference internal" href="#method-objects">9.3.4. Metot Nesneleri</a></li>
<li><a class="reference internal" href="#class-and-instance-variables">9.3.5. Sınıf ve Örnek Değişkenleri</a></li>
</ul>
</li>
<li><a class="reference internal" href="#random-remarks">9.4. Rastgele Açıklamalar</a></li>
<li><a class="reference internal" href="#inheritance">9.5. Kalıtım</a><ul>
<li><a class="reference internal" href="#multiple-inheritance">9.5.1. Çoklu Kalıtım</a></li>
</ul>
</li>
<li><a class="reference internal" href="#private-variables">9.6. Özel Değişkenler</a></li>
<li><a class="reference internal" href="#odds-and-ends">9.7. Oranlar ve Bitişler</a></li>
<li><a class="reference internal" href="#iterators">9.8. Yineleyiciler</a></li>
<li><a class="reference internal" href="#generators">9.9. Üreteçler</a></li>
<li><a class="reference internal" href="#generator-expressions">9.10. Üreteç İfadeleri</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Önceki konu</h4>
    <p class="topless"><a href="errors.html"
                          title="önceki bölüm"><span class="section-number">8. </span>Hatalar ve Özel Durumlar</a></p>
  </div>
  <div>
    <h4>Sonraki konu</h4>
    <p class="topless"><a href="stdlib.html"
                          title="sonraki bölüm"><span class="section-number">10. </span>Standart Kütüphanenin Özeti</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Bu Sayfa</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Hata Bildir</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/tutorial/classes.rst"
            rel="nofollow">Kaynağı Göster
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Gezinti</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Genel Endeks"
             accesskey="I">dizin</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Modül Dizini"
             >modülleri</a> |</li>
        <li class="right" >
          <a href="stdlib.html" title="10. Standart Kütüphanenin Özeti"
             accesskey="N">sonraki</a> |</li>
        <li class="right" >
          <a href="errors.html" title="8. Hatalar ve Özel Durumlar"
             accesskey="P">önceki</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python Öğreticisi</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9. </span>Sınıflar</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Hızlı Arama" aria-label="Hızlı Arama" type="text" name="q" />
          <input type="submit" value="Git" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="classes">
<span id="tut-classes"></span><h1><span class="section-number">9. </span>Sınıflar<a class="headerlink" href="#classes" title="Bu başlık için kalıcı bağlantı">¶</a></h1>
<p>Sınıflar, verileri ve işlevleri bir arada tutan bir araçtır. Yeni bir sınıf oluşturulurken, objeye ait yeni örnekler (instances) oluşturulur. Sınıf örnekleri, durumlarını korumak için onlara iliştirilmiş niteliklere sahip olabilir. Sınıfların durumunu modifiye etmek için ise metotlar kullanılabilir.</p>
<p>Diğer programlama dilleriyle karşılaştırıldığında, Python’un sınıf mekanizması olabildiğince az yeni sözdizimi ve semantik içeren sınıflar ekler.  C++ ve Modula-3’te bulunan sınıf mekanizmalarının bir karışımıdır.  Python sınıfları Nesne Yönelimli Programlama’nın tüm standart özelliklerini sağlar: sınıf devralma mekanizması birden çok temel sınıfa izin verir, türetilmiş bir sınıf temel sınıfının veya sınıflarının herhangi bir metodunu geçersiz kılabilir ve bir metot aynı ada sahip bir temel sınıfın metodunu çağırabilir.  Nesneler farklı miktar ve türlerde veri içerebilir.  Modüller için olduğu gibi, sınıflar da Python’un dinamik doğasına uygundur: çalışma sırasında oluşturulurlar ve oluşturulduktan sonra da değiştirilebilirler.</p>
<p>C++ terminolojisinde, normalde sınıf üyeleri (veri üyeleri dahil) <em>public</em> (aşağıdakine bakın <a class="reference internal" href="#tut-private"><span class="std std-ref">Özel Değişkenler</span></a>) ve tüm üye fonksiyonları <em>virtual</em>’ dır.  Modula-3’te olduğu gibi, nesnenin üyelerine metotlarından ulaşmak için bir kısayol yoktur: metodun işlevi, çağrı tarafından örtülü olarak sağlanan objeyi temsil eden açık bir argümanla bildirilir.  Smalltalk’ta olduğu gibi, sınıfların kendileri de birer nesnedir.  Bu sayede metotlar yeniden isimlendirilebilir veya içe aktarılabilir.  C++ ve Modula-3’ün aksine, yerleşik türler kullanıcının üzerlerine yapacağı geliştirmeler için temel sınıflar olarak kullanılabilir.  Ayrıca, C++’ta olduğu gibi, özel sözdizimine sahip çoğu yerleşik işleç (aritmetik işleçler, alt simgeleme vb.) sınıf örnekleri için yeniden tanımlanabilir, geliştirilebilir.</p>
<p>(Sınıflara dair evrensel terimlerin yanı sıra, nadiren Smalltalk ve C++ terimlerini kullanacağım. Onun yerine Modula-3 terimlerini kullanacağım çünkü Python’un nesne yönelimli semantiğine C++’tan daha yakın, yine de ancak çok az okuyucunun bunları duymuş olacağını tahmin ediyorum.)</p>
<section id="a-word-about-names-and-objects">
<span id="tut-object"></span><h2><span class="section-number">9.1. </span>İsim ve Nesneler Hakkında Birkaç Şey<a class="headerlink" href="#a-word-about-names-and-objects" title="Bu başlık için kalıcı bağlantı">¶</a></h2>
<p>Nesnelerin bireyselliği vardır ve birden çok ad (birden çok kapsamda) aynı nesneye bağlanabilir.  Bu, diğer dillerde örtüşme (aliasing) olarak bilinir.  Bu genellikle Python’a ilk bakışta takdir edilmeyen bir özellik olsa da değiştirilemeyen veri türleriyle (sayılar, dizeler, diziler) uğraşırken rahatlıkla göz ardı edilebilir.  Ancak, örtüşmeler, listeler, sözlükler ve diğer türlerin çoğu gibi değişebilir nesneleri içeren Python kodunun semantiği üzerinde şaşırtıcı bir etkiye sahiptir. Diğer adlar bazı açılardan işaretçiler (pointers) gibi davrandığından, bu genellikle programın yararına kullanılır.  Örneğin, bir nesneyi geçirmek kolaydır çünkü uygulama tarafından geçirilen şey yalnızca bir işaretçidir; bir fonksiyon argüman olarak geçirilen bir nesneyi değiştirirse, çağıran bu değişikliği görür — bu Pascal’daki iki farklı bağımsız değişken geçirme mekanizmasına olan gereksinimi ortadan kaldırır.</p>
</section>
<section id="python-scopes-and-namespaces">
<span id="tut-scopes"></span><h2><span class="section-number">9.2. </span>Python Etki Alanları ve Ad Alanları<a class="headerlink" href="#python-scopes-and-namespaces" title="Bu başlık için kalıcı bağlantı">¶</a></h2>
<p>Sınıflara başlamadan önce, size Python’un etki alanı kuralları hakkında bir şey söylemeliyim.  Sınıf tanımlarında ad alanlarının kullanımının bazı püf noktaları vardır ve neler olduğunu tam olarak anlamak için etki alanlarının ve isimlerin nasıl çalıştığını bilmeniz gerekir. Bu arada, bu konuda bilgi edinmek herhangi bir ileri düzey Python programcısı için yararlıdır.</p>
<p>Haydi birkaç tanımlama ile başlayalım.</p>
<p><em>Ad alanları</em> (namespace), adlardan nesnelere eşlemedir.  Çoğu isim şu anda Python sözlükleri olarak uygulanmaktadır, ancak bu fark edilir çapta bir fark yaratmaz (performans hariç) ve gelecekte değişebilir.  Ad alanlarına örnek olarak şunlar verilebilir: yerleşik isimler (<a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> ve yerleşik özel durum adları gibi fonksiyonları içerir); modüldeki global adlar; ve bir fonksiyon çağırmadaki yerel adlar.  Bir bakıma, bir nesnenin nitelik kümesi de bir ad alanı oluşturur.  İsimler hakkında bilinmesi gereken önemli şey, farklı ad alanlarındaki adlar arasında kesinlikle bir ilişki olmamasıdır; örneğin, iki farklı modülün her ikisi de karışıklık olmadan <code class="docutils literal notranslate"><span class="pre">maximize</span></code> fonksiyonunu tanımlayabilir — modül kullanıcılarının modül adını örneklemesi gerekir.</p>
<p>Bu arada, <em>nitelik</em> sözcüğünü bir noktayı takip eden herhangi bir isim için kullanıyorum. Mesela,  <code class="docutils literal notranslate"><span class="pre">z.real</span></code> ifadesinde <code class="docutils literal notranslate"><span class="pre">real</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> nesnesine ait bir niteliktir. Açıkçası, modüllerde isimlere yapılan referanslar nitelik referanslarıdır: <code class="docutils literal notranslate"><span class="pre">modname.funcname</span></code> ifadesinde <code class="docutils literal notranslate"><span class="pre">modname</span></code> bir modül nesnesi ve <code class="docutils literal notranslate"><span class="pre">funcname</span></code> onun bir niteliğidir. Bu durumda, modülün nitelikleri ve modüldeki global değişkenler arasında bir eşleşme olur: aynı ad alanını paylaşmaları! <a class="footnote-reference brackets" href="#id2" id="id1">1</a></p>
<p>Nitelikler salt okunur veya düzenlenebilir olabilir.  İkinci durumda, niteliklere atama yapmak mümkündür.  Modül nitelikleri düzenlenebilir: <code class="docutils literal notranslate"><span class="pre">modname.the_answer</span> <span class="pre">=</span> <span class="pre">42</span></code> yazabilirsiniz.  Düzenlenebilir nitelikler <a class="reference internal" href="../reference/simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> ifadesiyle de silinebilir.  Örneğin, <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">modname.the_answer</span></code> ifadesi <code class="xref py py-attr docutils literal notranslate"><span class="pre">the_answer</span></code> niteliğini <code class="docutils literal notranslate"><span class="pre">modname</span></code> tarafından adlandırılan nesneden kaldırır.</p>
<p>Ad alanları farklı anlarda oluşturulur ve farklı yaşam sürelerine sahiptir.  Yerleşik adları içeren ad alanı, Python yorumlayıcısı başlatıldığında oluşturulur ve hiçbir zaman silinmez.  Modül tanımı okunduğunda modül için genel ad alanı oluşturulur; normalde, modül ad alanları da yorumlayıcı çıkıp bitene kadar sürer.  Bir komut dosyasından veya etkileşimli olarak okunan yorumlayıcının en üst düzey çağrısı tarafından yürütülen ifadeler <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> adlı bir modülün parçası olarak kabul edilir, bu nedenle kendi genel ad alanlarına sahiptirler.  (Yerleşik isimler aslında bir modülde de yaşar; buna <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>.)</p>
<p>Bir işlevin yerel ad alanı, bir fonksiyon çağrıldığında oluşturulur ve fonksiyon başa çıkamadığı bir hata veya istisna ile karşılaştığında silinir.  (Aslında, bir bakıma ad alanı unutulmaktadır diyebiliriz.)  Tabii ki, özyinelemeli çağrıların her birinin kendi yerel ad alanı vardır.</p>
<p><em>scope</em>, bir ad alanının doğrudan erişilebilir olduğu Python programının metinsel bölgesidir.  Burada “Doğrudan erişilebilir”, niteliksiz bir başvurunun hedeflediği ismi ad alanında bulmaya çalıştığı anlamına gelir.</p>
<p>Kapsamlar statik olarak belirlense de, dinamik olarak kullanılırlar. Yürütme sırasında herhangi bir zamanda, ad alanlarına doğrudan erişilebilen 3 veya 4 iç içe kapsam vardır:</p>
<ul class="simple">
<li><p>en içte bulunan kapsam, ilk aranan olmakla birlikte yerel isimleri içerir</p></li>
<li><p>en yakın kapsayan kapsamdan başlayarak aranan kapsayan fonksiyonların kapsamları yerel olmayan, aynı zamanda genel olmayan adlar içerir</p></li>
<li><p>sondan bir önceki kapsam, geçerli modülün genel adlarını içerir</p></li>
<li><p>en dıştaki kapsam (en son aranan), yerleşik adlar içeren ad alanıdır</p></li>
</ul>
<p>Bir ad global olarak bildirilirse, tüm başvurular ve atamalar doğrudan modülün genel adlarını içeren orta kapsama gider.  En iç kapsamın dışında bulunan değişkenleri yeniden bağlamak için <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> ifadesi kullanılabilir; yerel olarak bildirilmezse de, bu değişkenler salt okunurdur (böyle bir değişken düzenlenirse, aynı adlı dış değişkeni değiştirmeden en iç kapsamda <em>yeni</em> bir yerel değişken oluşturur).</p>
<p>Genellikle, yerel kapsam (metinsel olarak) geçerli fonksiyonun yerel adlarına başvurur.  Dış fonksiyonlarda, yerel kapsam genel kapsamla aynı ad alanına başvurur: modülün ad alanı. Sınıf tanımları yerel kapsamda başka bir ad alanı yerleştirir.</p>
<p>Kapsamların metinsel olarak belirlendiğini fark etmek önemlidir: bir modülde tanımlanan bir işlevin genel kapsamı, işlevin nereden veya hangi diğer adla adlandırıldığından bağımsız olarak modülün ad alanıdır.  Öte yandan, gerçek ad araması dinamik olarak yapılır, çalışma zamanında — ancak, dil tanımı statik ad çözümlemelerine doğru, “derleme” zamanında gelişir, bu nedenle dinamik ad çözümlemesini güvenmeyin!  (Aslında, yerel değişkenler zaten statik olarak belirlenir.)</p>
<p>Python’un özel bir cilvesi, eğer <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> veya <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> deyimi geçerli değilse – isimlere yapılan atamaların her zaman en içteki kapsama girmesidir. Atamalar verileri kopyalamaz — adları nesnelere bağlarlar.  Aynı şey silme için de geçerlidir: <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> deyimi, <code class="docutils literal notranslate"><span class="pre">x</span></code> bağlamasını yerel kapsam tarafından başvurulan ad alanından kaldırır.  Aslında, yeni adlar tanıtan tüm işlemler yerel kapsamı kullanır: özellikle, <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> ifadeleri ve işlev tanımları modül veya işlev adını yerel kapsamda bağlar.</p>
<p><a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> deyimi, belirli değişkenlerin genel kapsamda yaşadığını ve orada geri alınması gerektiğini belirtmek için kullanılabilir; <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> deyimi, belirli değişkenlerin bir çevreleme kapsamında yaşadığını ve orada geri alınması gerektiğini gösterir.</p>
<section id="scopes-and-namespaces-example">
<span id="tut-scopeexample"></span><h3><span class="section-number">9.2.1. </span>Kapsamlar ve Ad Alanları Örneği<a class="headerlink" href="#scopes-and-namespaces-example" title="Bu başlık için kalıcı bağlantı">¶</a></h3>
<p>Bu, farklı kapsamlara ve ad alanlarına başvurmayı ve <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> ve <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> değişken bağlamasını nasıl etkileyeceğini gösteren bir örnektir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">scope_test</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">do_local</span><span class="p">():</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;local spam&quot;</span>

    <span class="k">def</span> <span class="nf">do_nonlocal</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">spam</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;nonlocal spam&quot;</span>

    <span class="k">def</span> <span class="nf">do_global</span><span class="p">():</span>
        <span class="k">global</span> <span class="n">spam</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;global spam&quot;</span>

    <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;test spam&quot;</span>
    <span class="n">do_local</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After local assignment:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
    <span class="n">do_nonlocal</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After nonlocal assignment:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
    <span class="n">do_global</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After global assignment:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>

<span class="n">scope_test</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In global scope:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
</pre></div>
</div>
<p>Örnek kodun çıktısı şudur:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
</pre></div>
</div>
<p>Varsayılan atama olan <em>local</em> atamasının <em>scope_test</em>'in <em>spam</em> bağlamasını nasıl değiştirmediğini unutmayın.  <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> ataması <em>scope_test</em>'in <em>spam</em> bağlamasını değiştirdi, hatta <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> ataması modül düzeyindeki bağlamasını değiştirdi.</p>
<p>Ayrıca <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> atamasından önce <em>spam</em> için herhangi bir bağlama olmadığını görebilirsiniz.</p>
</section>
</section>
<section id="a-first-look-at-classes">
<span id="tut-firstclasses"></span><h2><span class="section-number">9.3. </span>Sınıflara İlk Bakış<a class="headerlink" href="#a-first-look-at-classes" title="Bu başlık için kalıcı bağlantı">¶</a></h2>
<p>Sınıflar biraz yeni söz dizimi, üç yeni nesne türü ve bazı yeni semantiklere sahiptir.</p>
<section id="class-definition-syntax">
<span id="tut-classdefinition"></span><h3><span class="section-number">9.3.1. </span>Sınıf Tanımlama Söz Dizimi<a class="headerlink" href="#class-definition-syntax" title="Bu başlık için kalıcı bağlantı">¶</a></h3>
<p>Sınıf tanımlamasının en basit biçimi şöyledir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ClassName</span><span class="p">:</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Sınıf tanımlamaları, fonksiyon tanımlamaları (<a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a> deyimleri) ile aynı şekilde, herhangi bir etkiye sahip olmadan önce yürütülmelidir.  (Bir sınıf tanımını <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> ifadesinin bir dalına veya bir fonksiyonun içine yerleştirebilirsiniz.)</p>
<p>Uygulamada, bir sınıf tanımı içindeki ifadeler genellikle fonksiyon tanımlamaları olacaktır, ancak diğer ifadelere de izin verilir ve daha sonra bahsedeceğimiz üzere bazen yararlılardır. Bir sınıfın içindeki fonksiyon tanımları normalde, yöntemler için çağırma kuralları tarafından dikte edilen tuhaf bir bağımsız değişken listesi biçimine sahiptir — bu daha sonra açıklanacak.</p>
<p>Sınıf tanımı girildiğinde, yeni bir ad alanı oluşturulur ve yerel kapsam olarak kullanılır — böylece yerel değişkenlere yapılan tüm atamalar bu yeni ad alanına gider.  Özellikle, fonksiyon tanımlamaları yeni fonksiyonların adını buraya bağlar.</p>
<p>Bir sınıf tanımı normal olarak bırakıldığında (uç aracılığıyla), bir <em>sınıf nesnesi</em> oluşturulur.  Bu temelde sınıf tanımı tarafından oluşturulan ad alanının içerikleri için bir aracıdır, sınıf nesneleri hakkında daha fazla bilgiyi ise sonraki bölümde öğreneceğiz.  Orijinal yerel kapsam (sınıf tanımı girilmeden hemen önce geçerli olan) yeniden etkinleştirilir ve sınıf nesnesi burada sınıf tanımı üstbilgisinde verilen sınıf adına bağlı olur (örnekte <code class="xref py py-class docutils literal notranslate"><span class="pre">ClassName</span></code>).</p>
</section>
<section id="class-objects">
<span id="tut-classobjects"></span><h3><span class="section-number">9.3.2. </span>Sınıf Nesneleri<a class="headerlink" href="#class-objects" title="Bu başlık için kalıcı bağlantı">¶</a></h3>
<p>Sınıf nesneleri iki tür işlemi destekler: nitelik referansları ve örnekleme.</p>
<p><em>Nitelik referansları</em>, Python’daki tüm nitelik referansları için kullanılan standart söz dizimi olan <code class="docutils literal notranslate"><span class="pre">obj.name</span></code> kullanır.  Geçerli nitelik adları, sınıf nesnesi oluşturulduğunda sınıfın ad alanında bulunan tüm adlardır.  Yani, sınıf tanımı şöyle görünüyorsa:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A simple example class&quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">12345</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>
</pre></div>
</div>
<p>bu durumda <code class="docutils literal notranslate"><span class="pre">MyClass.i</span></code> ve <code class="docutils literal notranslate"><span class="pre">MyClass.f</span></code> geçerli nitelik referanslarıdır ve sırasıyla bir tamsayı ve fonksiyon nesnesi döndürür. Sınıf nitelikleri de atanabilir, böylece atamayla <code class="docutils literal notranslate"><span class="pre">MyClass.i</span></code> değerini değiştirebilirsiniz. Aynı zamanda <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code>, geçerli bir nitelik olarak sınıfa ait docstring döndürür: <code class="docutils literal notranslate"><span class="pre">&quot;Basit</span> <span class="pre">bir</span> <span class="pre">örnek</span> <span class="pre">sınıf&quot;</span></code>.</p>
<p>Sınıf <em>örnekleme</em> fonksiyon notasyonunu kullanır.  Sınıf nesnesinin, sınıfın yeni bir örneğini döndüren parametresiz bir fonksiyon olduğunu varsayın. Örneğin (yukarıdaki sınıfı varsayarsak):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</pre></div>
</div>
<p>sınıfın yeni bir <em>örnek</em> öğesini oluşturur ve bu nesneyi <code class="docutils literal notranslate"><span class="pre">x</span></code> yerel değişkenine atar.</p>
<p>Örnekleme işlemi (“sınıf nesnesi çağırma”) boş bir nesne oluşturur. Birçok sınıf, belirli bir başlangıç durumuna göre özelleştirilmiş örneklerle nesneler oluşturmayı sever. Bu nedenle bir sınıf, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> adlı özel bir metot tanımlayabilir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>Bir sınıf bir <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> metodunu tanımladığında, örnekleme işlemi yeni oluşturulan sınıf örneği için otomatik olarak <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> öğesini çağırır.  Bu örnekte, yeni başlatılmış bir örnek şu şekilde elde edilebilir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</pre></div>
</div>
<p>Tabii ki, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> yöntemi daha fazla esneklik için argümanlara sahip olabilir.  Bu durumda, sınıf örnekleme işlecine verilen bağımsız değişkenler <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> için aktarılır.  Mesela:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Complex</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">realpart</span><span class="p">,</span> <span class="n">imagpart</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">realpart</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">imagpart</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">i</span>
<span class="go">(3.0, -4.5)</span>
</pre></div>
</div>
</section>
<section id="instance-objects">
<span id="tut-instanceobjects"></span><h3><span class="section-number">9.3.3. </span>Örnek Nesneleri<a class="headerlink" href="#instance-objects" title="Bu başlık için kalıcı bağlantı">¶</a></h3>
<p>Şimdi örnek nesnelerle ne yapabiliriz?  Örnek nesneleri tarafından anlaşılan tek işlemler nitelik başvurularıdır.  İki tür geçerli öznitelik adı vardır: veri nitelikleri ve metotları.</p>
<p><em>veri nitelikleri</em>, Smalltalk’taki “örnek değişkenlerine” ve C++’taki “veri üyelerine” karşılık gelir.  Veri niteliklerinin önceden tanımlanması gerekmez; yerel değişkenler gibi, ilk değer atandığı anda varlıkları başlar.  Örneğin, <code class="docutils literal notranslate"><span class="pre">x</span></code> yukarıda oluşturulan <code class="xref py py-class docutils literal notranslate"><span class="pre">MyClass</span></code> örneğiyse, aşağıdaki kod parçası iz bırakmadan <code class="docutils literal notranslate"><span class="pre">16</span></code> değerini yazdırır:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
    <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">*</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">counter</span><span class="p">)</span>
<span class="k">del</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span>
</pre></div>
</div>
<p>Diğer örnek nitelik başvurusu türü bir <em>metot</em>. Metot, bir nesneye “ait” olan bir fonksiyondur.  (Python’da, terim metodu sınıf örneklerine özgü değildir: diğer nesne türlerinin de metotları olabilir.  Örneğin, liste nesnelerini genişletme, ekleme, kaldırma, sıralama vb. Ancak, aşağıdaki tartışmada, aksi açıkça belirtilmedikçe, yalnızca sınıf örneği nesnelerinin metotlarını ifade etmek için terim metodunu kullanacağız.)</p>
<p id="index-0">Örnek nesnesinin geçerli metot adları nesnenin sınıfına bağlıdır.  Fonksiyon nesneleri olan bir sınıfın tüm nitelikleri, örneklerinin karşılık gelen fonksiyonlarını tanımlar.  Bu nedenle, örneğimizde, <code class="docutils literal notranslate"><span class="pre">x.f</span></code> geçerli bir metot referansıdır, ne de olsa <code class="docutils literal notranslate"><span class="pre">MyClass.f</span></code> bir fonksiyondur ancak <code class="docutils literal notranslate"><span class="pre">MyClass.i</span></code> fonksiyon olmadığından <code class="docutils literal notranslate"><span class="pre">x.i</span></code> değildir.  Ancak <code class="docutils literal notranslate"><span class="pre">x.f</span></code>, <code class="docutils literal notranslate"><span class="pre">MyClass.f</span></code> ile aynı şey değildir çünkü bir fonksiyon nesnesi değil, <em>metot nesnesi</em> ‘dir.</p>
</section>
<section id="method-objects">
<span id="tut-methodobjects"></span><h3><span class="section-number">9.3.4. </span>Metot Nesneleri<a class="headerlink" href="#method-objects" title="Bu başlık için kalıcı bağlantı">¶</a></h3>
<p>Genellikle, bir metot bağlandıktan hemen sonra çağrılır:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">MyClass</span></code> örneğinde, <code class="docutils literal notranslate"><span class="pre">hello</span> <span class="pre">world</span></code> string’ini döndürür. Lakin, hemen bir metot çağırmak gerekli değildir: <code class="docutils literal notranslate"><span class="pre">x.f</span></code> bir metot nesnesidir, yani daha sonra depolanabilir ve çağrılabilir.  Mesela:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">xf</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">f</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">xf</span><span class="p">())</span>
</pre></div>
</div>
<p>daima <code class="docutils literal notranslate"><span class="pre">hello</span> <span class="pre">world</span></code> yazdırmaya devam edecek.</p>
<p>Bir yöntem çağrıldığında tam olarak ne gerçekleşir?  <code class="xref py py-meth docutils literal notranslate"><span class="pre">f()</span></code> fonksiyon tanımı bir argüman belirtmiş olsa da, <code class="docutils literal notranslate"><span class="pre">x.f()</span></code> öğesinin yukarıda bir argüman olmadan çağrıldığını fark etmiş olabilirsiniz.  Peki argümana ne oldu? Elbette Python, argüman gerektiren bir fonksiyon, argüman verilmemiş iken çağırılırsa — fonksiyon aslında kullanılmasa bile hata verir…</p>
<p>Aslında, cevabı tahmin etmiş olabilirsiniz: yöntemlerle ilgili özel şey, örnek nesnesinin fonksiyonun ilk argüman olarak geçirilmesidir.  Örneğimizde, <code class="docutils literal notranslate"><span class="pre">x.f()</span></code> çağrısı tam olarak <code class="docutils literal notranslate"><span class="pre">MyClass.f(x)</span></code> ile eş değerdir.  Genel olarak, <em>n</em> tane argümana sahip bir metodu çağırmak, ilk argümandan önce metodun örnek nesnesi eklenerek oluşturulan bir argüman listesiyle karşılık gelen fonksiyonu çağırmaya eş değerdir.</p>
<p>Metotların nasıl çalıştığını hala anlamıyorsanız, nasıl uygulandığına bakmak belki de sorunları açıklığa kavuşturabilir.  Bir örneğin, veri olmayan bir niteliğine başvurulduğu zaman bu örneğin ait olduğu sınıfa bakılır.  Ad bir fonksiyon nesnesi olan geçerli bir sınıf özniteliğini gösterirse, örnek nesne ve fonksiyon nesnesi soyut bir nesnede paketlenerek (işaretçiler) bir metot nesnesi oluşturulur. İşte bu metot nesnesidir.  Metot nesnesi bir argüman listesiyle çağrıldığında, örnek nesneden ve argüman listesinden yeni bir argüman listesi oluşturulur ve fonksiyon nesnesi bu yeni argüman listesiyle çağrılır.</p>
</section>
<section id="class-and-instance-variables">
<span id="tut-class-and-instance-variables"></span><h3><span class="section-number">9.3.5. </span>Sınıf ve Örnek Değişkenleri<a class="headerlink" href="#class-and-instance-variables" title="Bu başlık için kalıcı bağlantı">¶</a></h3>
<p>Genel olarak, örnek değişkenleri o örneğe özgü veriler içindir ve sınıf değişkenleri sınıfın tüm örnekleri tarafından paylaşılan nitelikler ile metotlar içindir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;canine&#39;</span>         <span class="c1"># class variable shared by all instances</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>    <span class="c1"># instance variable unique to each instance</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">kind</span>                  <span class="c1"># shared by all dogs</span>
<span class="s1">&#39;canine&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">kind</span>                  <span class="c1"># shared by all dogs</span>
<span class="s1">&#39;canine&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span>                  <span class="c1"># unique to d</span>
<span class="s1">&#39;Fido&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span>                  <span class="c1"># unique to e</span>
<span class="s1">&#39;Buddy&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#tut-object"><span class="std std-ref">İsim ve Nesneler Hakkında Birkaç Şey</span></a> ‘te anlatıldığı gibi, paylaşılan veriler listeler ve sözlükler gibi <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a> nesnelerini içeren şaşırtıcı etkilere sahip olabilir. Örneğin, aşağıdaki koddaki <em>tricks</em> listesi sınıf değişkeni olarak kullanılmamalıdır, çünkü yalnızca tek bir liste tüm <em>Dog</em> örnekleri tarafından paylaşılacaktır:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>

    <span class="n">tricks</span> <span class="o">=</span> <span class="p">[]</span>             <span class="c1"># mistaken use of a class variable</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">add_trick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trick</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tricks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trick</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;roll over&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;play dead&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">tricks</span>                <span class="c1"># unexpectedly shared by all dogs</span>
<span class="p">[</span><span class="s1">&#39;roll over&#39;</span><span class="p">,</span> <span class="s1">&#39;play dead&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Doğru olan ise veriyi paylaşmak yerine bir örnek değişkeni kullanmaktır:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tricks</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># creates a new empty list for each dog</span>

    <span class="k">def</span> <span class="nf">add_trick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trick</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tricks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trick</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;roll over&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;play dead&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">tricks</span>
<span class="p">[</span><span class="s1">&#39;roll over&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">tricks</span>
<span class="p">[</span><span class="s1">&#39;play dead&#39;</span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="random-remarks">
<span id="tut-remarks"></span><h2><span class="section-number">9.4. </span>Rastgele Açıklamalar<a class="headerlink" href="#random-remarks" title="Bu başlık için kalıcı bağlantı">¶</a></h2>
<p>Aynı nitelik adı hem bir örnekte hem de bir sınıfta oluşuyorsa, nitelik araması örneğe öncelik verir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Warehouse</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">purpose</span> <span class="o">=</span> <span class="s1">&#39;storage&#39;</span>
<span class="gp">... </span>   <span class="n">region</span> <span class="o">=</span> <span class="s1">&#39;west&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w1</span> <span class="o">=</span> <span class="n">Warehouse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">w1</span><span class="o">.</span><span class="n">purpose</span><span class="p">,</span> <span class="n">w1</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>
<span class="go">storage west</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w2</span> <span class="o">=</span> <span class="n">Warehouse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w2</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="s1">&#39;east&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">w2</span><span class="o">.</span><span class="n">purpose</span><span class="p">,</span> <span class="n">w2</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>
<span class="go">storage east</span>
</pre></div>
</div>
<p>Veri niteliklerine metotların yanı sıra bir nesnenin sıradan kullanıcıları (“istemciler”) tarafından başvurulabilir.  Başka bir deyişle, sınıflar saf soyut veri türlerini uygulamak için kullanılamaz.  Aslında, Python’daki hiçbir şey, veri gizlemeyi zorlamaz. Bu durum geleneksel kullanımından dolayı bu şekildedir.  (Öte yandan, C ile yazılan Python uygulamaları, uygulama ayrıntılarını tamamen gizleyebilir ve gerekirse bir nesneye erişimi kontrol edebilir; bu, C ile yazılmış Python uzantıları tarafından kullanılabilir.)</p>
<p>İstemciler veri niteliklerini dikkatle kullanmalıdır — istemciler veri özniteliklerini damgalayarak yöntemler tarafından tutulan değişmezleri bozabilir.  İstemcilerin, metotların geçerliliğini etkilemeden bir örnek nesnesine kendi veri niteliklerini ekleyebileceğini unutmayın. Tabii ki burada da ad çakışmalarından kaçınılmalıdır, adlandırma kuralları ise kaçınmak için oldukça faydalı olabilir.</p>
<p>Yöntemlerin içinden veri niteliklerine (veya diğer metotlara!) başvurmak için kısa yol yoktur.  Bu aslında metotların okunabilirliğini arttırıyor, çünkü bir metoda bakarken yerel değişkenleri ve örnek değişkenlerini karıştırma ihtimali bırakmamış oluyoruz.</p>
<p>Genellikle, bir metodun ilk bağımsız değişkenine <code class="docutils literal notranslate"><span class="pre">self</span></code> denir.  Bu bir kullanım geleneğinden başka bir şey değildir, yani <code class="docutils literal notranslate"><span class="pre">self</span></code> adının Python için kesinlikle özel bir anlamı yoktur.  Bununla birlikte, kurala uymadığınızda kodunuzun diğer Python programcıları tarafından daha az okunabilir olabileceğini ve yazılabilecek potansiyel bir <em>sınıf tarayıcısı</em> programının bu kurala dayanıyor olabileceğini unutmayın.</p>
<p>Sınıf niteliği olan herhangi bir fonksiyon nesnesi, bu sınıfın örnekleri için bir metot tanımlar.  Fonksiyon tanımının metinsel olarak sınıf tanımına dahil olması gerekli değildir: sınıftaki yerel bir değişkene fonksiyon nesnesi atamak da uygundur.  Mesela:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Function defined outside the class</span>
<span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f1</span>

    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">g</span>
</pre></div>
</div>
<p>Buradaki <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code> ve <code class="docutils literal notranslate"><span class="pre">h</span></code> fonksiyonları nesnelerine başvuran <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> sınıfının bütün nitelikleridir ve sonuç olarak hepsi <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> — <code class="docutils literal notranslate"><span class="pre">h</span></code> sınıfının örneklerinin metotları olarak tümüyle <code class="docutils literal notranslate"><span class="pre">g</span></code> ‘ye eş değerdir.  Bu kullanım şeklinin genellikle yalnızca bir programı okuyan kişinin kafasını karıştırmaya yaradığını unutmayın.</p>
<p>Metotlar, <code class="docutils literal notranslate"><span class="pre">self</span></code> bağımsız değişkeninin metot niteliklerini kullanarak diğer metotları çağırabilir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Bag</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">addtwice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Metotlar, global adlara sıradan işlevler gibi başvuru yapabilir.  Bir metotla ilişkili genel kapsam, tanımını içeren modüldür.  (Bir sınıf hiçbir zaman genel kapsam olarak kullanılmaz.)  Global verileri bir metotta kullanmak için nadiren iyi bir nedenle karşılaşılsa da, genel kapsamın birçok meşru kullanımı vardır: bir kere, genel kapsamlıya içe aktarılan fonksiyon ve modüller, metotlar ve içinde tanımlanan fonksiyonlar ve sınıflar tarafından kullanılabilir.  Genellikle, metodu içeren sınıfın kendisi bu genel kapsamda tanımlanır ve sonraki bölümde bir yöntemin kendi sınıfına başvurmak istemesinin bazı iyi nedenlerini bulacağız.</p>
<p>Her değer bir nesnedir ve bu nedenle bir <em>sınıf</em> (<em>type</em> olarak da adlandırılır) bulundurur. <code class="docutils literal notranslate"><span class="pre">object.__class__</span></code> olarak depolanır.</p>
</section>
<section id="inheritance">
<span id="tut-inheritance"></span><h2><span class="section-number">9.5. </span>Kalıtım<a class="headerlink" href="#inheritance" title="Bu başlık için kalıcı bağlantı">¶</a></h2>
<p>Tabii ki, bir dil özelliği kalıtımı desteklemeden “sınıf” adına layık olmaz.  Türetilmiş sınıf tanımının söz dizimi şöyle görünür:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">BaseClassName</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseClassName</span></code> adı, türetilmiş sınıf tanımını içeren bir kapsamda tanımlanmalıdır.  Temel sınıf adı yerine, diğer rasgele ifadelere de izin verilir.  Bu, örneğin, temel sınıf başka bir modülde tanımlandığında yararlı olabilir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">modname</span><span class="o">.</span><span class="n">BaseClassName</span><span class="p">):</span>
</pre></div>
</div>
<p>Türetilmiş bir sınıf tanımının yürütülmesi, temel sınıfla aynı şekilde devam eder. Sınıf nesnesi inşa edildiğinde, temel sınıf hatırlanır.  Bu, nitelik başvurularını çözmek için kullanılır: istenen nitelik sınıfta bulunmazsa, arama temel sınıfa bakmaya devam eder.  Temel sınıfın kendisi başka bir sınıftan türetilmişse, bu kural özyinelemeli olarak uygulanır.</p>
<p>Türetilmiş sınıfların somutlaştırılmasında özel bir şey yoktur: <code class="docutils literal notranslate"><span class="pre">DerivedClassName()</span></code> sınıfın yeni bir örneğini oluşturur.  Metot başvuruları aşağıdaki gibi çözümlenir: ilgili sınıf niteliği aranır, gerekirse temel sınıflar zincirinin aşağısına inilir ve bu bir fonksiyon nesnesi veriyorsa metot başvurusu geçerlidir.</p>
<p>Türetilmiş sınıflar, temel sınıflarının metotlarını geçersiz kılabilir.  Metotlar aynı nesnenin diğer yöntemlerini çağırırken özel ayrıcalıkları olmadığından, aynı temel sınıfta tanımlanan başka bir metodu çağıran bir temel sınıfın metodu, onu geçersiz kılan türetilmiş bir sınıfın metodunu çağırabilir.  (C++ programcıları için: Python’daki tüm yöntemler etkili bir şekilde <code class="docutils literal notranslate"><span class="pre">sanal</span></code>.)</p>
<p>Türetilmiş bir sınıfta geçersiz kılma yöntemi aslında yalnızca aynı adlı temel sınıf yöntemini değiştirmek yerine genişletmek isteyebilir. Temel sınıf metodunu doğrudan çağırmanın basit bir yolu vardır: sadece <code class="docutils literal notranslate"><span class="pre">BaseClassName.methodname(self,</span> <span class="pre">arguments)</span></code> çağırın.  Bu bazen müşteriler için de yararlıdır.  (Bunun yalnızca temel sınıfa genel kapsamda <code class="docutils literal notranslate"><span class="pre">BaseClassName</span></code> olarak erişilebiliyorsa çalıştığını unutmayın.)</p>
<p>Python’un kalıtımla çalışan iki yerleşik fonksiyonu vardır:</p>
<ul class="simple">
<li><p>Bir örneğin türünü denetlemek için <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> kullanın: <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">int)</span></code> yalnızca <code class="docutils literal notranslate"><span class="pre">obj.__class__</span></code> <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> veya <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> sınıfından türetilmiş bir sınıfsa <code class="docutils literal notranslate"><span class="pre">True</span></code> olacaktır.</p></li>
<li><p>Sınıf kalıtımını denetlemek için <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> kullanın: <code class="docutils literal notranslate"><span class="pre">issubclass(bool,</span> <span class="pre">int)</span></code> <code class="docutils literal notranslate"><span class="pre">True</span></code> ‘dur, çünkü <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> ‘in bir alt sınıfıdır.  Ancak, <code class="docutils literal notranslate"><span class="pre">issubclass(float,</span> <span class="pre">int)</span></code> <code class="docutils literal notranslate"><span class="pre">False</span></code> olduğundan <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> alt sınıfı değildir.</p></li>
</ul>
<section id="multiple-inheritance">
<span id="tut-multiple"></span><h3><span class="section-number">9.5.1. </span>Çoklu Kalıtım<a class="headerlink" href="#multiple-inheritance" title="Bu başlık için kalıcı bağlantı">¶</a></h3>
<p>Python, çoklu kalıtım biçimini de destekler.  Birden çok temel sınıf içeren bir sınıf tanımı şöyle görünür:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span><span class="p">,</span> <span class="n">Base3</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Basitçe, bir üst sınıftan devralınan nitelikleri aramayı, hiyerarşide çakışmanın olduğu aynı sınıfta iki kez arama yapmadan, derinlik öncelikli, soldan sağa olarak düşünebilirsiniz. Bu nedenle, bir nitelik <code class="xref py py-class docutils literal notranslate"><span class="pre">DerivedClassName</span></code> içinde bulunamazsa, <code class="xref py py-class docutils literal notranslate"><span class="pre">Base1</span></code> ‘de, sonra (özyinelemeli olarak) <code class="xref py py-class docutils literal notranslate"><span class="pre">Base1</span></code> temel sınıflarında aranır ve orada bulunamazsa <code class="xref py py-class docutils literal notranslate"><span class="pre">Base2</span></code> vb.</p>
<p>Aslında, durum bundan biraz daha karmaşıktır: yöntem çözümleme sırası, <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> için işbirliği çağrılarını desteklemek için dinamik olarak değişir.  Bu yaklaşım, diğer bazı çoklu kalıtım dillerinde sonraki çağrı yöntemi olarak bilinir ve tekli kalıtım dillerinde bulunan süper çağrıdan daha güçlüdür.</p>
<p>Çoklu kalıtımın tüm durumları bir veya daha fazla elmas ilişkisi gösterdiğinden (üst sınıflardan en az birine, en alttaki sınıftan birden çok yol üzerinden erişilebildiği ilişkiler) dinamik sıralama gereklidir.  Örneğin, tüm sınıflar <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> öğesini devralır, bu nedenle çoklu kalıtım durumu <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> ‘e ulaşmak için birden fazla yol sağlar. Temel sınıflara birden çok kez erişilmesini önlemek için, dinamik algoritma arama sırasını her sınıfta belirtilen soldan sağa sıralamayı koruyacak şekilde doğrular, her üst öğeyi yalnızca bir kez çağırır ve monotondur (yani bir sınıf, üst sınıfının öncelik sırasını etkilemeden alt sınıflandırılabilir). Birlikte ele alındığında, bu özellikler çoklu kalıtım ile güvenilir ve genişletilebilir sınıflar tasarlamayı mümkün kılar.  Daha fazla ayrıntı için bkz. <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a>.</p>
</section>
</section>
<section id="private-variables">
<span id="tut-private"></span><h2><span class="section-number">9.6. </span>Özel Değişkenler<a class="headerlink" href="#private-variables" title="Bu başlık için kalıcı bağlantı">¶</a></h2>
<p>Python’da bir nesnenin içinden erişilmesi dışında asla erişilemeyen “özel” örnek değişkenleri yoktur.  Ancak, çoğu Python kodu tarafından izlenen bir kural vardır: alt çizgi (örneğin <code class="docutils literal notranslate"><span class="pre">_spam</span></code>) ile öneklenmiş bir ad API’nin genel olmayan bir parçası olarak kabul edilmelidir (bir fonksiyon, metot veya veri üyesi olsun).  Bir uygulama detayıdır ve önceden haber verilmeksizin değiştirilebilir.</p>
<p id="index-1">Sınıf-özel üyeler için geçerli bir kullanım örneği olduğundan (yani alt sınıflar tarafından tanımlanan adlara sahip adların ad çakışmasını önlemek için), <em class="dfn">name mangling</em> adı verilen böyle bir mekanizma için sınırlı destek vardır.  <code class="docutils literal notranslate"><span class="pre">__spam</span></code> formunun herhangi bir tanımlayıcısı (en az iki satır altı, en fazla bir alt çizgi) metinsel olarak <code class="docutils literal notranslate"><span class="pre">_classname__spam</span></code> ile değiştirilir;  Bu mangling, bir sınıfın tanımı içinde gerçekleştiği sürece tanımlayıcının söz dizimsel konumuna bakılmaksızın yapılır.</p>
<p>Ad mangling, alt sınıfların sınıf içi metot çağrılarını kesmeden metotları geçersiz kılmasına izin vermek için yararlıdır.  Mesela:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mapping</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">items_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="n">__update</span> <span class="o">=</span> <span class="n">update</span>   <span class="c1"># private copy of original update() method</span>

<span class="k">class</span> <span class="nc">MappingSubclass</span><span class="p">(</span><span class="n">Mapping</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># provides new signature for update()</span>
        <span class="c1"># but does not break __init__()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">items_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</pre></div>
</div>
<p>Yukarıdaki örnek, <code class="docutils literal notranslate"><span class="pre">MappingSubclass</span></code> sırasıyla <code class="docutils literal notranslate"><span class="pre">Mapping</span></code> sınıfında <code class="docutils literal notranslate"><span class="pre">_Mapping__update</span></code> ve <code class="docutils literal notranslate"><span class="pre">mappingSubclass</span></code> sınıfında <code class="docutils literal notranslate"><span class="pre">_MappingSubclass__update</span></code> ile değiştirildiği için <code class="docutils literal notranslate"><span class="pre">__update</span></code> tanımlayıcısı tanıtsa bile çalışır.</p>
<p>Mangling kurallarının çoğunlukla kazaları önlemek için tasarlandığını unutmayın; özel olarak kabul edilen bir değişkene erişmek veya değiştirmek hala mümkündür.  Bu, hata ayıklayıcı gibi özel durumlarda bile yararlı olabilir.</p>
<p><code class="docutils literal notranslate"><span class="pre">exec()</span></code> veya <code class="docutils literal notranslate"><span class="pre">eval()</span></code> koduna geçirilen kodun çağırma sınıfının sınıf adını geçerli sınıf olarak görmediğine dikkat edin; bu, etkisi aynı şekilde birlikte bayt derlenmiş kodla sınırlı olan <code class="docutils literal notranslate"><span class="pre">global</span></code> deyiminin etkisine benzer.  Aynı kısıtlama <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>, <code class="docutils literal notranslate"><span class="pre">setattr()</span></code> ve <code class="docutils literal notranslate"><span class="pre">delattr()</span></code> ve doğrudan <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> atıfta bulunurken de geçerlidir.</p>
</section>
<section id="odds-and-ends">
<span id="tut-odds"></span><h2><span class="section-number">9.7. </span>Oranlar ve Bitişler<a class="headerlink" href="#odds-and-ends" title="Bu başlık için kalıcı bağlantı">¶</a></h2>
<p>Bazen, birkaç adlandırılmış veri öğesini bir araya getirerek Pascal “kaydı” veya C “yapısına” benzer bir veri türüne sahip olmak yararlıdır.  Boş bir sınıf tanımı güzel bir şekilde yapacaktır:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="n">john</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">()</span>  <span class="c1"># Create an empty employee record</span>

<span class="c1"># Fill the fields of the record</span>
<span class="n">john</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;John Doe&#39;</span>
<span class="n">john</span><span class="o">.</span><span class="n">dept</span> <span class="o">=</span> <span class="s1">&#39;computer lab&#39;</span>
<span class="n">john</span><span class="o">.</span><span class="n">salary</span> <span class="o">=</span> <span class="mi">1000</span>
</pre></div>
</div>
<p>Belirli bir soyut veri türünü bekleyen Python kodunun bir parçası genellikle bunun yerine bu veri türünün yöntemlerine öykünen bir sınıfa geçirilebilir.  Örneğin, bir dosya nesnesinden bazı verileri biçimlendiren bir fonksiyonunuz varsa, bunun yerine verileri bir dize arabelleğinden alan ve bağımsız değişken olarak geçiren <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> ve <code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code> yöntemlerine sahip bir sınıf tanımlayabilirsiniz.</p>
<p>Örnek yöntem nesnelerinin de nitelikleri vardır: <code class="docutils literal notranslate"><span class="pre">m.__self__</span></code> yöntemi olan örnek nesnedir <code class="xref py py-meth docutils literal notranslate"><span class="pre">m()</span></code>, ve <code class="docutils literal notranslate"><span class="pre">m.__func__</span></code> yönteme karşılık gelen fonksiyon nesnesidir.</p>
</section>
<section id="iterators">
<span id="tut-iterators"></span><h2><span class="section-number">9.8. </span>Yineleyiciler<a class="headerlink" href="#iterators" title="Bu başlık için kalıcı bağlantı">¶</a></h2>
<p>Şimdiye kadar büyük olasılıkla çoğu kapsayıcı nesnenin bir <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> deyimi kullanılarak döngüye alınabileceğini fark etmişsinizdir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="s2">&quot;123&quot;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;myfile.txt&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Bu erişim tarzı açık, özlü ve kullanışlıdır.  Yineleyicilerin kullanımı Python’u istila eder ve birleştirir.  Perde arkasında <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> deyimi kapsayıcı nesne üzerinde <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> öğesini çağırır.  Fonksiyon, kapsayıcıdaki öğelere teker teker erişen <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> metodunu tanımlayan bir yineleyici nesnesi döndürür.  Başka öğe olmadığında, <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a>, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> döngüsünün sonlandırılacağını bildiren bir <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> hatası oluşturur.  <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> yerleşik fonksiyonunu kullanarak <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> yöntemini çağırabilirsiniz; Bu örnek, her şeyin nasıl çalıştığını gösterir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span>
<span class="go">&lt;str_iterator object at 0x10c90e650&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
    <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>Yineleme protokolünün arkasındaki mekaniği gördükten sonra, sınıflarınıza yineleme davranışı eklemek kolaydır.  <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> metodu ile bir nesne döndüren <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> metodunu tanımlayın.  Sınıf  <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code> tanımlarsa, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code>  sadece  <code class="docutils literal notranslate"><span class="pre">self</span></code> döndürebilir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Reverse</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rev</span> <span class="o">=</span> <span class="n">Reverse</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">iter</span><span class="p">(</span><span class="n">rev</span><span class="p">)</span>
<span class="go">&lt;__main__.Reverse object at 0x00A1DB50&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">rev</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">m</span>
<span class="go">a</span>
<span class="go">p</span>
<span class="go">s</span>
</pre></div>
</div>
</section>
<section id="generators">
<span id="tut-generators"></span><h2><span class="section-number">9.9. </span>Üreteçler<a class="headerlink" href="#generators" title="Bu başlık için kalıcı bağlantı">¶</a></h2>
<p><a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">Üreteçler</span></a> yineleyiciler oluşturmak için basit ve güçlü bir araçtır.  Normal fonksiyonlar gibi yazılırlar, ancak veri döndürmek istediklerinde <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> deyimini kullanırlar.  Üzerinde her <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> çağrıldığı zaman, üreteç kaldığı yerden devam eder (tüm veri değerlerini ve hangi deyimin en son yürütüldüğını hatırlar).  Bu örnek, üreteçlerin oluşturulmasının ne kadar da kolay olabileceğini gösterir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">reverse</span><span class="p">(</span><span class="s1">&#39;golf&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">f</span>
<span class="go">l</span>
<span class="go">o</span>
<span class="go">g</span>
</pre></div>
</div>
<p>Üreteçlerle yapılabilecek her şey, önceki bölümde açıklandığı gibi sınıf tabanlı yineleyicilerle de yapılabilir.  Üreteçleri bu kadar kompakt yapan şey: <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> ve <a class="reference internal" href="../reference/expressions.html#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> yöntemlerinin otomatik olarak oluşturulmasıdır.</p>
<p>Başka bir önemli özellik, yerel değişkenlerin ve yürütme durumunun çağrılar arasında otomatik olarak kaydedilmesidir.  Bu, fonksiyonun yazılmasını kolaylaştırdı ve <code class="docutils literal notranslate"><span class="pre">self.index</span></code> ve <code class="docutils literal notranslate"><span class="pre">self.data</span></code> gibi değişkenleri kullanmaya kıyasla çok daha net hale getirdi.</p>
<p>Otomatik metot oluşturma ve kaydetme programı durumuna ek olarak, üreteçler sonlandırıldığında otomatik olarak <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> ‘ı yükseltirler. Birlikte, bu özellikler normal bir işlev yazmaktan daha fazla çaba harcamadan yinelemeler oluşturmayı kolaylaştırır.</p>
</section>
<section id="generator-expressions">
<span id="tut-genexps"></span><h2><span class="section-number">9.10. </span>Üreteç İfadeleri<a class="headerlink" href="#generator-expressions" title="Bu başlık için kalıcı bağlantı">¶</a></h2>
<p>Bazı basit üreteçler, listelere benzer bir söz dizimi kullanılarak ve köşeli ayraçlar yerine parantezlerle kısaca kodlanabilir. Bu ifadeler, üreteçlerin kapsayıcı bir fonksiyon tarafından hemen kullanıldığı durumlar için tasarlanmıştır.  Üreteç ifadeleri tam üreteç tanımlarından daha kompakt ancak daha az çok yönlüdür ve aynı özellikle liste anlamalarından daha bellek dostu olma eğilimindedir.</p>
<p>Örnekler:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>                 <span class="c1"># sum of squares</span>
<span class="go">285</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">xvec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yvec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span> <span class="n">yvec</span><span class="p">))</span>         <span class="c1"># dot product</span>
<span class="go">260</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">unique_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">word</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">page</span>  <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">valedictorian</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">student</span><span class="o">.</span><span class="n">gpa</span><span class="p">,</span> <span class="n">student</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">student</span> <span class="ow">in</span> <span class="n">graduates</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;golf&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[&#39;f&#39;, &#39;l&#39;, &#39;o&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
<p class="rubric">Dipnotlar</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Bir şey hariç.  Modül nesneleri,  <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>  denen sadece okunabilir bir özelliğe sahiptir, bu da modülün ad alanını uygulamak için bir sözlük döndürür: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> ismi bir özellik olsa da global bir isim değildir. Kuşkusuz, bu durum ad alanlarının soyutlanış özelliklerine aykırı, dolayısıyla sadece programın durması sonrası çalışan hata ayıklayıcılar gibilerinin kullanımına kısıtlanmalı.</p>
</dd>
</dl>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">İçindekiler</a></h3>
    <ul>
<li><a class="reference internal" href="#">9. Sınıflar</a><ul>
<li><a class="reference internal" href="#a-word-about-names-and-objects">9.1. İsim ve Nesneler Hakkında Birkaç Şey</a></li>
<li><a class="reference internal" href="#python-scopes-and-namespaces">9.2. Python Etki Alanları ve Ad Alanları</a><ul>
<li><a class="reference internal" href="#scopes-and-namespaces-example">9.2.1. Kapsamlar ve Ad Alanları Örneği</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-first-look-at-classes">9.3. Sınıflara İlk Bakış</a><ul>
<li><a class="reference internal" href="#class-definition-syntax">9.3.1. Sınıf Tanımlama Söz Dizimi</a></li>
<li><a class="reference internal" href="#class-objects">9.3.2. Sınıf Nesneleri</a></li>
<li><a class="reference internal" href="#instance-objects">9.3.3. Örnek Nesneleri</a></li>
<li><a class="reference internal" href="#method-objects">9.3.4. Metot Nesneleri</a></li>
<li><a class="reference internal" href="#class-and-instance-variables">9.3.5. Sınıf ve Örnek Değişkenleri</a></li>
</ul>
</li>
<li><a class="reference internal" href="#random-remarks">9.4. Rastgele Açıklamalar</a></li>
<li><a class="reference internal" href="#inheritance">9.5. Kalıtım</a><ul>
<li><a class="reference internal" href="#multiple-inheritance">9.5.1. Çoklu Kalıtım</a></li>
</ul>
</li>
<li><a class="reference internal" href="#private-variables">9.6. Özel Değişkenler</a></li>
<li><a class="reference internal" href="#odds-and-ends">9.7. Oranlar ve Bitişler</a></li>
<li><a class="reference internal" href="#iterators">9.8. Yineleyiciler</a></li>
<li><a class="reference internal" href="#generators">9.9. Üreteçler</a></li>
<li><a class="reference internal" href="#generator-expressions">9.10. Üreteç İfadeleri</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Önceki konu</h4>
    <p class="topless"><a href="errors.html"
                          title="önceki bölüm"><span class="section-number">8. </span>Hatalar ve Özel Durumlar</a></p>
  </div>
  <div>
    <h4>Sonraki konu</h4>
    <p class="topless"><a href="stdlib.html"
                          title="sonraki bölüm"><span class="section-number">10. </span>Standart Kütüphanenin Özeti</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Bu Sayfa</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Hata Bildir</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/tutorial/classes.rst"
            rel="nofollow">Kaynağı Göster
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Gezinti</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Genel Endeks"
             >dizin</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Modül Dizini"
             >modülleri</a> |</li>
        <li class="right" >
          <a href="stdlib.html" title="10. Standart Kütüphanenin Özeti"
             >sonraki</a> |</li>
        <li class="right" >
          <a href="errors.html" title="8. Hatalar ve Özel Durumlar"
             >önceki</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python Öğreticisi</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9. </span>Sınıflar</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Hızlı Arama" aria-label="Hızlı Arama" type="text" name="q" />
          <input type="submit" value="Git" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Telif Hakkı</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Son güncelleme: Ara 28, 2022.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>